以下流程基于已通过测试的代码结构，特别是其 **Log 数组索引 0 存储 LastIncludedIndex 处条目** 的索引约定。

### I. 状态与初始化 (`Make` 函数)

Raft 节点以 **Follower** 状态启动。

| 状态类型 | 变量 | 初始化值 / 结构 | 作用 |
| :--- | :--- | :--- | :--- |
| **持久化** | `rf.CurrentTerm` | 0 | 节点看到的最新任期。 |
| | `rf.VotedFor` | -1 | 当前任期内投票给的候选人 ID。 |
| | `rf.Log` | `[{Term: 0}]` | 日志数组，初始包含一个索引 0 的虚拟条目。 |
| **易失性** | `rf.State` | `Follower` | 节点当前的角色。 |
| | `rf.CommitIndex` | 0 | 已知已提交的最高日志索引。 |
| | `rf.LastApplied` | 0 | 已应用到状态机的最高日志索引。 |
| **协程** | `rf.ticker()` | 启动 | 定时发送心跳或检查选举超时。 |
| | `rf.applyDaemon()` | 启动 | 异步地将已提交的日志/快照应用到 `rf.applyCh`。 |

---

### II. 领导人选举 (`RequestVote` RPC)

1.  **Candidate 转变：** `rf.ticker()` 选举超时，节点转为 Candidate。
    * **更新：** `rf.CurrentTerm` 递增，`rf.VotedFor = rf.me`。
    * **持久化：** 调用 `rf.persist()`。
2.  **发送请求：** Candidate 向所有节点发送 `RequestVote` RPC，携带 $\text{CurrentTerm}$ 和自己的日志新旧信息。
3.  **Follower 投票处理：**
    * **任期检查：** 如果 $\text{args.Term} > \text{rf.CurrentTerm}$，Follower 更新任期并转为 Follower。
    * **安全检查：** Follower 仅在尚未投票且 Candidate 日志至少和自己一样新时投赞成票。
4.  **Leader 产生：** Candidate 收到多数票后，立即转变为 Leader，并初始化 Leader 专用状态 (`rf.NextIndex` 和 `rf.MatchIndex`)。

---

### III. 日志复制 (`Start` 和 `AppendEntries` RPC)

#### A. 客户端请求提交 (`rf.Start(command)`)

1.  **Leader 校验：** 确保当前节点是 Leader。
2.  **本地追加：** 将命令封装为 $\text{LogEntry}$，追加到 $\text{rf.Log}$ 末尾。
3.  **持久化：** 调用 `rf.persist()`。
4.  **复制请求：** Leader 启动协程，使用 $\text{NextIndex}[i]$ 发送 $\text{AppendEntries}$ RPC。

#### B. 日志复制和冲突解决 (`AppendEntries` 处理器)

1.  **Follower 一致性检查：** Follower 检查其 $\text{PrevLogIndex}$ 处的日志是否存在，且任期是否与 $\text{args.PrevLogTerm}$ **匹配**。
2.  **冲突优化（快速回退）：**
    * **不匹配时：** Follower 不仅返回失败，还会返回冲突的 $\text{Term}$ ($\text{ConflictTerm}$) 和该 $\text{Term}$ 在 Follower 日志中**第一个出现**的索引 ($\text{ConflictIndex}$)。
    * **Leader 接收：** Leader 利用这些信息，**以任期为单位跳过**不匹配的日志，一次性大幅减少 $\text{NextIndex}$，加速同步。
3.  **日志应用：** 检查通过后，Follower 追加日志，更新 $\text{rf.CommitIndex}$，并调用 $\text{rf.persist()}$。

---

### IV. 日志/快照应用 (`applyDaemon` 协程)

`applyDaemon` 确保已提交的日志和快照被顺序应用到状态机。

1.  **快照 Liveness 检查（核心修复）：**
    * 检查 $\text{rf.LastApplied} < \text{rf.LastIncludedIndex}$。
    * **操作：** 在锁内，将 $\text{rf.LastApplied}$ **显式**更新为 $\text{rf.LastIncludedIndex}$。
    * 发送快照 $\text{ApplyMsg}$ 到 $\text{rf.applyCh}$。
2.  **日志应用检查：**
    * 检查 $\text{rf.CommitIndex} > \text{rf.LastApplied}$。
    * 提取 $(\text{LastApplied} + 1)$ 到 $\text{CommitIndex}$ 的日志。
    * **更新：** 在锁内，将 $\text{rf.LastApplied}$ 更新为 $\text{rf.CommitIndex}$。
    * 发送日志 $\text{ApplyMsg}$ 到 $\text{rf.applyCh}$。

---

### V. 快照机制 (`Snapshot` 和 `InstallSnapshot`)

#### A. Leader/Follower 本地快照 (`Snapshot` 函数)

1.  **日志裁剪：** 在 $\text{index}$ 处执行裁剪，丢弃 $\text{index}$ 及其之前的日志。
2.  **状态重建（关键修复）：**
    * 获取快照点 $\text{index}$ 的 $\text{Term}$。
    * **重建 Log：** `rf.Log` 被**强制重建**为：`[LII 处的哨兵条目] + [LII+1 之后的日志后缀]`。这维持了 **Log Array Index 0 存储 LII 处条目** 的索引约定。
3.  **同步状态：** $\text{rf.LastIncludedIndex}$ 和 $\text{rf.LastIncludedTerm}$ 更新。
4.  **Liveness/Safety：** $\text{rf.LastApplied}$ **必须**同步推进到 $\text{index}$，以确保应用状态一致性。
5.  **持久化：** $\text{rf.persister.Save()}$。

#### B. 快照安装 (`InstallSnapshot` 处理器)

1.  **检查：** Follower 检查 $\text{args.LastIncludedIndex}$ 是否比自身 $\text{rf.LastIncludedIndex}$ 新。
2.  **日志处理：** 检查 $\text{LII}_{new}$ 处的 $\text{Term}$ 是否匹配。
    * **匹配：** 保留 $LII$ 之后的日志后缀。
    * **不匹配/太短：** 丢弃所有日志。
3.  **状态重建（关键修复）：** 无论匹配与否，`rf.Log` 都会被**重建**，以新的 $\text{args.LastIncludedTerm}$ 作为 $\text{rf.Log}[0]$ 的哨兵条目。
4.  **应用同步：** $\text{rf.CommitIndex}$ 和 $\text{rf.LastApplied}$ 同步推进到 $\text{args.LastIncludedIndex}$。
5.  **应用触发：** `applyDaemon` 随后检测到 $LII$ 变化，发送快照 $\text{ApplyMsg}$。